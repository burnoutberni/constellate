// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  // Use PostgreSQL for production and development
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model - supports both local and remote (federated) users
model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Basic info
  username      String  @unique
  email         String? @unique // Only for local users
  emailVerified Boolean @default(false)
  name          String?

  // Profile customization
  displayColor String  @default("#3b82f6") // User's color for calendar events
  timezone     String  @default("UTC") // Preferred IANA timezone identifier
  bio          String?
  profileImage String? // URL to profile image
  headerImage  String? // URL to header/banner image

  // Federation
  isRemote         Boolean @default(false)
  externalActorUrl String? @unique // Full ActivityPub actor URL for remote users
  publicKey        String? // PEM format RSA public key
  privateKey       String? // PEM format RSA private key (only for local users)
  inboxUrl         String? // Remote user's inbox URL
  sharedInboxUrl   String? // Remote user's shared inbox URL

  // Admin role
  isAdmin Boolean @default(false) // Admin users can moderate content

  // Bot flag
  isBot Boolean @default(false) // Bot users (for crawlers, automated accounts)

  // Privacy settings
  autoAcceptFollowers Boolean @default(true) // Automatically accept follow requests

  // Relations
  events                 Event[]
  following              Following[]       @relation("UserFollowing")
  followers              Follower[]        @relation("UserFollowers")
  eventAttendance        EventAttendance[]
  eventLikes             EventLike[]
  comments               Comment[]
  notifications          Notification[]    @relation("NotificationRecipient")
  triggeredNotifications Notification[]    @relation("NotificationActor")
  mentionsReceived       CommentMention[]
  inboxItems             InboxItem[]
  blockedUsers           BlockedUser[]     @relation("BlockingUser")
  blockedBy              BlockedUser[]     @relation("BlockedUser")
  reports                Report[]          @relation("Reporter")
  reportedIn             Report[]          @relation("ReportedUser")
  eventTemplates         EventTemplate[]
  reminders              EventReminder[]

  // Auth
  sessions Session[]
  accounts Account[]
  apiKeys  ApiKey[]

  @@index([username])
  @@index([externalActorUrl])
}

enum NotificationType {
  FOLLOW
  COMMENT
  LIKE
  MENTION
  EVENT
  SYSTEM
}

model Notification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation("NotificationRecipient", fields: [userId], references: [id], onDelete: Cascade)

  actorId String?
  actor   User?   @relation("NotificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  type       NotificationType
  title      String
  body       String?
  contextUrl String?
  data       Json?
  read       Boolean          @default(false)
  readAt     DateTime?

  @@index([userId, read])
  @@index([userId, createdAt])
}

// Event model - calendar events with ActivityPub support
model Event {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Basic event info
  title       String
  summary     String? // Description
  location    String?
  locationLatitude Float? // Decimal degrees
  locationLongitude Float? // Decimal degrees
  headerImage String? // Event banner image
  url         String? // External URL for more info

  // Timing
  startTime  DateTime
  endTime    DateTime?
  duration   String? // ISO 8601 duration format
  timezone   String          @default("UTC")
  visibility EventVisibility @default(PUBLIC)

  // ActivityPub extended properties
  eventStatus             String? // EventScheduled, EventCancelled, EventPostponed
  eventAttendanceMode     String? // OfflineEventAttendanceMode, OnlineEventAttendanceMode, MixedEventAttendanceMode
  maximumAttendeeCapacity Int?

  // Federation
  attributedTo String? // ActivityPub actor URL of event creator
  externalId   String? @unique // For remote events

  // Relations
  userId            String?
  user              User?              @relation(fields: [userId], references: [id], onDelete: Cascade)
  attendance        EventAttendance[]
  likes             EventLike[]
  comments          Comment[]
  tags              EventTag[]
  reminders         EventReminder[]
  recurrencePattern RecurrencePattern?
  recurrenceEndDate DateTime?
  sharedEventId     String?
  sharedEvent       Event?             @relation("EventShares", fields: [sharedEventId], references: [id], onDelete: Cascade)
  shares            Event[]            @relation("EventShares")
  // Note: Unique constraint on [userId, sharedEventId] removed because:
  // - When userId is null (remote events), multiple NULL values in composite unique constraints
  //   are not treated as violations in SQL databases, allowing duplicate shares
  // - Application-level validation should prevent duplicate shares for local users
  // - For remote events, uniqueness should be handled via externalId or attributedTo

  @@index([userId])
  @@index([startTime])
  @@index([externalId])
  @@index([recurrenceEndDate])
  @@index([sharedEventId])
  @@index([locationLatitude, locationLongitude])
}

enum EventVisibility {
  PUBLIC
  FOLLOWERS
  PRIVATE
  UNLISTED
}

// Following relationship - who the user follows
model Following {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Local user who is following
  userId String
  user   User   @relation("UserFollowing", fields: [userId], references: [id], onDelete: Cascade)

  // Actor being followed (can be local or remote)
  actorUrl       String // Full ActivityPub actor URL
  username       String // Display username
  inboxUrl       String // Where to send activities
  sharedInboxUrl String? // Shared inbox if available
  iconUrl        String? // Profile icon URL
  accepted       Boolean @default(false) // Whether the follow was accepted

  @@unique([userId, actorUrl])
  @@index([userId])
}

// Follower relationship - who follows the user
model Follower {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Local user being followed
  userId String
  user   User   @relation("UserFollowers", fields: [userId], references: [id], onDelete: Cascade)

  // Actor who is following (can be local or remote)
  actorUrl       String // Full ActivityPub actor URL
  username       String // Display username
  inboxUrl       String // Where to send activities
  sharedInboxUrl String? // Shared inbox if available
  iconUrl        String? // Profile icon URL
  accepted       Boolean @default(false) // Whether the follow was accepted

  @@unique([userId, actorUrl])
  @@index([userId])
}

// Event attendance (RSVP)
model EventAttendance {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Status: "attending", "maybe", "not_attending"
  status String

  // Federation tracking
  externalId String? @unique // For remote attendance

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
}

// Event likes/bookmarks
model EventLike {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Federation tracking
  externalId String? @unique // For remote likes

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
}

// Comments on events (federated as Note objects)
model Comment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  content String

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Threading support
  inReplyToId String?
  inReplyTo   Comment?  @relation("CommentReplies", fields: [inReplyToId], references: [id], onDelete: Cascade)
  replies     Comment[] @relation("CommentReplies")

  // Federation tracking
  externalId String? @unique // For remote comments

  mentions CommentMention[]

  @@index([eventId])
  @@index([authorId])
  @@index([inReplyToId])
}

// Mentions within comments (used for notifications)
model CommentMention {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  commentId String
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  mentionedUserId String
  mentionedUser   User   @relation(fields: [mentionedUserId], references: [id], onDelete: Cascade)

  handle String // Stored as typed (e.g., @username or @username@domain)

  @@unique([commentId, mentionedUserId])
  @@index([commentId])
  @@index([mentionedUserId])
}

// Event tags/hashtags
model EventTag {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  tag String // Hashtag without the #

  @@unique([eventId, tag])
  @@index([tag])
}

model EventTemplate {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  name        String
  description String?
  data        Json

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
  @@index([userId])
}

// Inbox items for activity feed
model InboxItem {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Activity details
  type      String // Activity type (Create, Update, Like, etc.)
  actorUrl  String // Who performed the activity
  objectUrl String // What was acted upon
  content   String? // Summary/content for display
  read      Boolean @default(false)

  @@index([userId, read])
  @@index([createdAt])
}

// Processed activities for deduplication
model ProcessedActivity {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  activityId String   @unique // The ActivityPub activity ID
  expiresAt  DateTime // 30 days from creation

  @@index([activityId])
  @@index([expiresAt])
}

// User blocking
model BlockedUser {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  blockingUserId String
  blockingUser   User   @relation("BlockingUser", fields: [blockingUserId], references: [id], onDelete: Cascade)

  blockedUserId String
  blockedUser   User   @relation("BlockedUser", fields: [blockedUserId], references: [id], onDelete: Cascade)

  @@unique([blockingUserId, blockedUserId])
  @@index([blockingUserId])
}

// Domain blocking (admin only)
model BlockedDomain {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  domain String  @unique
  reason String?

  @@index([domain])
}

// Content reports
model Report {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reporterId String
  reporter   User   @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)

  reportedUserId String?
  reportedUser   User?   @relation("ReportedUser", fields: [reportedUserId], references: [id], onDelete: SetNull)

  contentUrl String? // URL of reported content
  reason     String
  status     String  @default("pending") // pending, reviewed, resolved

  @@index([reporterId])
  @@index([reportedUserId])
  @@index([status])
}

// Better-Auth Models

model Session {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Account {
  id           String    @id
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  userId       String
  accountId    String
  providerId   String
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?
  password     String?
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
}

// API Keys for bot authentication
model ApiKey {
  id         String    @id @default(cuid())
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  lastUsedAt DateTime?

  // Key details
  name    String // Human-readable name for the key
  keyHash String @unique // Hashed API key (never store plain text)
  prefix  String // First 8 characters for display (e.g., "sk_live_")

  // User association
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Metadata
  description String? // Optional description

  @@index([userId])
  @@index([keyHash])
}

enum RecurrencePattern {
  DAILY
  WEEKLY
  MONTHLY
}

enum ReminderStatus {
  PENDING
  SENDING
  SENT
  FAILED
  CANCELLED
}

// Event reminders - scheduled notifications for users
model EventReminder {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Reminder configuration
  minutesBeforeStart Int // Minutes before event start to send reminder
  remindAt           DateTime // Calculated time when reminder should be sent

  // Status tracking
  status ReminderStatus @default(PENDING)

  // Delivery tracking
  deliveredAt   DateTime? // When reminder was successfully delivered
  lastAttemptAt DateTime? // Last time we attempted to send
  failureReason String?   // Error message if delivery failed

  @@unique([eventId, userId])
  @@index([userId])
  @@index([eventId])
  @@index([status, remindAt])
}
